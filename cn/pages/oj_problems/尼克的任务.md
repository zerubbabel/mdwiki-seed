# 尼克的任务

---

Description

尼克每天上班之前都连接上英特网，接收他的上司发来的邮件，这些邮件包含了尼克主管的部门当天要完成的全部任务，每个任务由一个开始时刻与一个持续时间构成。 
尼克的一个工作日为N分钟，从第一分钟开始到第N分钟结束。当尼克到达单位后他就开始干活。如果在同一时刻有多个任务需要完成，尼克可以任选其中的一个来做，而其余的则由他的同事完成，反之如果只有一个任务，则该任务必需由尼克去写成，假如某些任务开始时刻尼克正在工作，则这些任务也由尼克的同事完成。如果某任务于第P分钟开始，持续时间为T分钟，则该任务将在第P+T-1分钟结束。 
写一个程序计算尼克应该如何选取任务，才能获得最大的空暇时间。

Input

输入数据第一行包含两个用空格隔开的整数N和K，1≤N≤10000，1≤K≤10000，N表示尼克的工作时间，单位为分，K表示任务总数。 
接下来共有K行，每一行有两个用空格隔开的整数P和T，表示该任务从第P分钟开始，持续时间为T分钟，其中1≤P≤N，1≤P+T-1≤N。

Output

输出文件仅一行包含一个整数表示尼克可能获得的最大空暇时间。

Sample Input


15 6
1 2
1 6
4 11
8 5
8 1
11 5
Sample Output


4


【分析】

  	粗看是贪心，贪心有漏洞，可以找出各种反例。
    本题是一道资源分配类DP。我们可以划分阶段的标准是时间和任务。

	  如果尼克在一个时间点上没有接到任务，我们就让他延续他原来的空闲时段，现在空闲时间=上一个空闲点的空闲时间+1；      

	  如果这时有这个时间点开始的任务，我们就将其插入，有多个这样的任务供我们选择最优的。

    因为这个时间点尼克只有两个选择：要么完成一个任务，要么什么都不干。以开始时间来选择每一次都可以找到一个最优的。但是本题好在开始时间和完成时间都有一个严格的限定，所以我们可以不用考虑一个任务插入在哪个时间结束，只要根据开始时间和结束时间进行插入控制就行了。

    我们定义状态：f[i]表示从i开始到结束的最大空闲值。

   不难得到状态转移方程：

                         f[i]=f[i+1]+1         if(p[j]!=i) //时间点i没有任务

                      f[i]=max{f[i+t[j]]}   if(p[j]==i)

【代码】

```c++
#include<algorithm>
using namespace std;
int N,K;
int P[10005],T[10005],f[10005];
void _init()
{
	scanf("%d%d",&N,&K);
	for(int i=1;i<=K;i++)
		scanf("%d%d",&P[i],&T[i]);
}
void _solve()
{
	int j=K;
	for(int i=N;i;i--)    //逆序
	{
		if(P[j]!=i)
			f[i]=f[i+1]+1;
		else
		{
			while(P[j]==i)    //若起始时间一样，取最优
			{
				f[i]=max(f[i],f[i+T[j]]);
				j--;
			}
		}
	}
	printf("%d\n",f[1]);
}
int main()
{
	_init();
	_solve();
	return 0;
}
```